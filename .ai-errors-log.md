# 🤖 AI 自我进化日志 (.ai-errors-log.md)

> 此文件是 AI 的外部长期记忆。
> **指令**：每次开始新任务前，AI 必须读取此文件，检查是否有相关的历史错误模式，避免重蹈覆辙。

## 🧠 错误模式库

### 代码规范

- **PATTERN-001**: 路径处理
  - **特征**: 使用 `+ '/'` 或 `+ '\\'` 拼接路径，或使用 `os.path.join()`
  - **修正**: 使用 `pathlib.Path` 对象，更简洁现代
  - **示例**: `Path.home() / "Library/Application Support/App"`
  - **Python 3.10+**: 优先使用 `/` 操作符进行路径拼接

- **PATTERN-002**: 类型提示简化
  - **特征**: 使用 `Optional[str] = None` 等复杂类型提示
  - **修正**: Python 3.10+ 使用 `str | None` 语法，更简洁
  - **示例**: `def func(file: str | None = None) -> str:`
  - **注意**: Python 3.9 及以下仍需使用 `Optional[str]`

- **PATTERN-007**: 代码优化
  - **特征**: 重复代码块、调试日志、深层嵌套条件、未用导入
  - **修正**: 提取公共函数、删除调试日志、简化条件逻辑、清理导入
  - **示例**: `_run_script()`, `_item()`, 提前返回、字典映射
  - **Python 特性**: 使用字典映射替代多个 if-elif，使用 `match-case`（Python 3.10+）

### Python 异步编程

- **PATTERN-008**: 异步函数调用
  - **特征**: 在同步函数中直接调用异步函数，或忘记使用 `await`
  - **修正**: 使用 `await` 调用异步函数，或使用 `asyncio.run()` 运行异步代码
  - **示例**: 
    ```python
    # 错误
    result = async_func()
    
    # 正确
    result = await async_func()
    ```

- **PATTERN-009**: 异步上下文管理
  - **特征**: 忘记使用 `async with` 管理异步资源
  - **修正**: 使用 `async with` 确保资源正确释放
  - **示例**: 
    ```python
    # 错误
    client = create_client()
    result = await client.call()
    
    # 正确
    async with create_client() as client:
        result = await client.call()
    ```

- **PATTERN-010**: 事件循环管理
  - **特征**: 在已有事件循环中创建新的事件循环
  - **修正**: 检查是否已有事件循环，使用 `asyncio.get_event_loop()` 或 `asyncio.new_event_loop()`
  - **示例**: 
    ```python
    # 错误
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    # 正确
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    ```

### OpenCode SDK 集成

- **PATTERN-018**: 客户端连接管理
  - **特征**: 未检查客户端连接状态就直接调用 API
  - **修正**: 先检查客户端是否已连接，或使用健康检查 API
  - **示例**: 
    ```python
    # 错误
    result = await client.session.create(...)
    
    # 正确
    health = await client.global.health()
    if not health.healthy:
        raise ConnectionError("Client not healthy")
    result = await client.session.create(...)
    ```

- **PATTERN-019**: 事件流订阅
  - **特征**: 事件流订阅未正确处理取消和清理
  - **修正**: 使用 `asyncio.Task` 管理订阅，确保正确取消和清理资源
  - **示例**: 
    ```python
    # 错误
    async for event in client.event.subscribe():
        process(event)
    
    # 正确
    task = asyncio.create_task(subscribe_events())
    try:
        await task
    finally:
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            pass
    ```

- **PATTERN-020**: 会话状态管理
  - **特征**: 未正确处理会话状态变化，导致状态不一致
  - **修正**: 通过事件流监听会话状态变化，及时更新本地状态
  - **示例**: 
    ```python
    # 错误
    session = await client.session.create(...)
    # 直接使用，可能状态已变化
    
    # 正确
    session = await client.session.create(...)
    async for event in client.event.subscribe():
        if event.type == "session.status" and event.sessionID == session.id:
            update_session_status(event.status)
    ```

- **PATTERN-021**: 权限请求处理
  - **特征**: 权限请求未及时响应，导致任务阻塞
  - **修正**: 监听权限请求事件，及时响应用户决策
  - **示例**: 
    ```python
    # 错误
    await client.session.prompt(...)
    # 如果遇到权限请求，任务会一直阻塞
    
    # 正确
    async def handle_permissions():
        async for event in client.event.subscribe():
            if event.type == "permission.asked":
                decision = await get_user_decision(event)
                await client.permission.reply({
                    "requestID": event.requestID,
                    "reply": decision
                })
    
    asyncio.create_task(handle_permissions())
    await client.session.prompt(...)
    ```

- **PATTERN-022**: 错误处理和重试
  - **特征**: API 调用失败后未正确处理，或未实现重试机制
  - **修正**: 实现重试机制，区分可重试和不可重试的错误
  - **示例**: 
    ```python
    # 错误
    result = await client.session.create(...)
    
    # 正确
    max_retries = 3
    for attempt in range(max_retries):
        try:
            result = await client.session.create(...)
            break
        except ConnectionError as e:
            if attempt == max_retries - 1:
                raise
            await asyncio.sleep(2 ** attempt)  # 指数退避
    ```

### 工作区管理

- **PATTERN-023**: 工作区路径处理
  - **特征**: 使用字符串拼接处理工作区路径，未规范化路径
  - **修正**: 使用 `pathlib.Path` 规范化路径，处理相对路径和绝对路径
  - **示例**: 
    ```python
    # 错误
    workspace_path = base_path + "/workspace"
    
    # 正确
    workspace_path = Path(base_path) / "workspace"
    workspace_path = workspace_path.resolve()  # 规范化路径
    ```

- **PATTERN-024**: 配置文件读写
  - **特征**: 配置文件读写未处理并发和错误情况
  - **修正**: 使用文件锁或原子操作，处理文件不存在和格式错误
  - **示例**: 
    ```python
    # 错误
    with open(config_path, "w") as f:
        json.dump(config, f)
    
    # 正确
    import tempfile
    import shutil
    
    temp_path = config_path.with_suffix(".tmp")
    with open(temp_path, "w") as f:
        json.dump(config, f, indent=2)
    shutil.move(temp_path, config_path)  # 原子操作
    ```

- **PATTERN-025**: 授权目录验证
  - **特征**: 未验证授权目录是否在允许范围内
  - **修正**: 检查请求的路径是否在授权目录列表中或其子目录
  - **示例**: 
    ```python
    # 错误
    if requested_path in authorized_dirs:
        allow()
    
    # 正确
    def is_authorized(path: Path, authorized_dirs: list[Path]) -> bool:
        path = path.resolve()
        return any(path.is_relative_to(auth_dir.resolve()) for auth_dir in authorized_dirs)
    ```

### 会话管理

- **PATTERN-026**: 会话选择状态
  - **特征**: 切换会话时未清理前一个会话的状态
  - **修正**: 切换会话时清理消息、待办事项等状态，重新加载新会话数据
  - **示例**: 
    ```python
    # 错误
    current_session_id = new_session_id
    # 消息和待办事项仍然是旧会话的
    
    # 正确
    current_session_id = new_session_id
    messages = await client.session.messages({"sessionID": new_session_id})
    todos = await client.session.todo({"sessionID": new_session_id})
    ```

- **PATTERN-027**: 事件流过滤
  - **特征**: 处理所有事件，未过滤当前会话相关的事件
  - **修正**: 只处理当前选中会话的事件，忽略其他会话的事件
  - **示例**: 
    ```python
    # 错误
    async for event in client.event.subscribe():
        if event.type == "message.updated":
            update_message(event.message)
    
    # 正确
    current_session_id = get_current_session_id()
    async for event in client.event.subscribe():
        if event.type == "message.updated":
            if event.message.sessionID == current_session_id:
                update_message(event.message)
    ```

### 模板管理

- **PATTERN-028**: 模板文件格式
  - **特征**: 模板文件格式不一致，解析失败
  - **修正**: 统一模板格式（Markdown frontmatter 或 JSON），提供格式验证
  - **示例**: 
    ```python
    # 错误
    template = json.loads(content)  # 可能是 Markdown 格式
    
    # 正确
    def parse_template(content: str) -> dict:
        # 尝试解析 Markdown frontmatter
        if content.startswith("---"):
            return parse_frontmatter(content)
        # 尝试解析 JSON
        try:
            return json.loads(content)
        except json.JSONDecodeError:
            raise ValueError("Invalid template format")
    ```

- **PATTERN-029**: 模板作用域
  - **特征**: 未区分工作区模板和全局模板
  - **修正**: 明确模板作用域，工作区模板保存在 `.openwork/templates`，全局模板保存在全局位置
  - **示例**: 
    ```python
    # 错误
    template_path = templates_dir / template_id
    
    # 正确
    if scope == "workspace":
        template_path = workspace_path / ".openwork/templates" / template_id
    else:
        template_path = global_templates_dir / template_id
    ```

### 扩展管理

- **PATTERN-030**: 扩展重载
  - **特征**: 安装扩展后未重新加载引擎，扩展不生效
  - **修正**: 安装扩展后标记需要重载，提示用户重新加载引擎
  - **示例**: 
    ```python
    # 错误
    install_skill(skill_path)
    # 扩展未生效
    
    # 正确
    install_skill(skill_path)
    mark_reload_required("skills")
    # 提示用户重新加载引擎
    ```

- **PATTERN-031**: 扩展配置更新
  - **特征**: 直接修改 `opencode.json`，未处理格式和错误
  - **修正**: 使用 JSONC 解析器，保留注释，验证配置格式
  - **示例**: 
    ```python
    # 错误
    config = json.loads(content)
    config["plugin"].append("new-plugin")
    json.dump(config, open(config_path, "w"))
    
    # 正确
    from jsonc_parser import parse as parse_jsonc
    
    config = parse_jsonc(content)
    if "plugin" not in config:
        config["plugin"] = []
    config["plugin"].append("new-plugin")
    
    # 使用格式化工具保持格式
    formatted = json.dumps(config, indent=2, ensure_ascii=False)
    config_path.write_text(formatted + "\n")
    ```

### 重构陷阱

- **PATTERN-013**: 函数返回值
  - **特征**: 调用返回新对象的函数时未接收返回值
  - **修正**: 必须接收返回值 `obj = func(obj, ...)`
  - **Python 特性**: 注意可变对象和不可变对象的区别

- **PATTERN-014**: 导入语句
  - **特征**: 重构时删除或遗漏必要的 import 语句
  - **修正**: 重构后验证所有导入语句完整
  - **Python 特性**: 使用 `from __future__ import annotations` 支持延迟类型注解

- **PATTERN-015**: 状态重置
  - **特征**: 用户选择"取消"后错误重置状态跟踪变量
  - **修正**: 取消操作保持状态不变，只有执行操作后才重置
  - **应用场景**: 会话选择、权限决策、模板创建等

## 关键经验

### OpenCode SDK 最佳实践

1. **健康检查优先**：在调用任何 API 前先检查客户端健康状态
2. **事件流管理**：使用 `asyncio.Task` 管理事件流订阅，确保正确清理
3. **会话状态同步**：通过事件流实时同步会话状态，避免状态不一致
4. **权限及时响应**：监听权限请求事件，及时响应用户决策，避免任务阻塞
5. **错误重试机制**：实现指数退避重试，区分可重试和不可重试的错误

### 工作区管理最佳实践

1. **路径规范化**：使用 `pathlib.Path` 规范化所有路径，处理相对路径和绝对路径
2. **配置文件原子操作**：使用临时文件 + 移动操作，确保配置文件更新的原子性
3. **授权目录验证**：检查请求路径是否在授权目录范围内，支持子目录访问

### 异步编程最佳实践

1. **资源管理**：使用 `async with` 确保异步资源正确释放
2. **事件循环检查**：检查是否已有事件循环，避免创建多个事件循环
3. **任务取消**：正确取消异步任务，处理 `CancelledError` 异常

### 扩展管理最佳实践

1. **配置格式保持**：使用 JSONC 解析器保留注释，保持配置文件格式
2. **重载标记**：安装扩展后标记需要重载，提示用户重新加载引擎
3. **作用域区分**：明确区分工作区扩展和全局扩展

## 架构模式参考（基于 openwork-dev）

### 工作区管理模式
- **工作区即文件夹**：每个工作区对应一个文件夹路径
- **配置分离**：工作区配置保存在 `.openwork/openwork.json`，OpenCode 配置保存在 `opencode.json`
- **授权目录管理**：每个工作区维护授权目录列表，限制访问范围

### 会话管理模式
- **会话即任务**：每个会话对应一个 AI 任务执行上下文
- **会话隔离**：不同会话之间的状态和权限相互独立
- **事件流订阅**：通过 SSE 实时接收会话更新

### 权限管理模式
- **最小权限原则**：默认拒绝，需要明确授权
- **权限级别**：允许一次、允许会话、始终允许
- **权限审计**：记录所有权限决策，便于审计

### 扩展管理模式
- **Skills**：存储在 `.opencode/skill` 目录，通过 OpenPackage 安装
- **Plugins**：配置在 `opencode.json` 的 `plugin` 字段
- **MCP**：配置在 `opencode.json` 的 `mcp` 字段
- **热重载**：扩展变更后需要重新加载引擎才能生效
