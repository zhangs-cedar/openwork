# 🤖 AI 自我进化日志 (.ai-errors-log.md)

> 此文件是 AI 的外部长期记忆。
> **指令**：每次开始新任务前，AI 必须读取此文件，检查是否有相关的历史错误模式，避免重蹈覆辙。

## 🧠 错误模式库

### 代码规范

- **PATTERN-001**: 路径处理
  - **特征**: 使用 `+ '/'` 或 `+ '\\'` 拼接路径，或使用 `os.path.join()`
  - **修正**: 使用 `pathlib.Path` 对象，更简洁现代
  - **示例**: `Path.home() / "Library/Application Support/App"`

- **PATTERN-002**: 类型提示简化
  - **特征**: 使用 `Optional[str] = None` 等复杂类型提示
  - **修正**: 遵循 liuns 风格，简化为 `str = None`
  - **示例**: `def func(file: str = None) -> str:`

- **PATTERN-007**: 代码优化
  - **特征**: 重复代码块、调试日志、深层嵌套条件、未用导入
  - **修正**: 提取公共函数、删除调试日志、简化条件逻辑、清理导入
  - **示例**: `_run_script()`, `_item()`, 提前返回、字典映射

### macOS 开发

- **PATTERN-003**: 通知 vs 弹窗
  - **特征**: 使用 `NSUserNotificationCenter` 展示重要信息
  - **修正**: 重要信息用 `NSAlert` 弹窗，通知仅用于后台提醒

- **PATTERN-004**: 打包后路径
  - **特征**: 使用 `__file__` 定位配置文件
  - **修正**: 打包后 bundle 内文件只读，用户数据存 `~/Library/Application Support/`

- **PATTERN-005**: Finder 检测
  - **特征**: 使用 `target of front window` 获取目标路径
  - **修正**: 使用 `insertion location` 获取准确的插入位置

- **PATTERN-006**: 权限管理
  - **特征**: 每次打包后需重新授权
  - **修正**: 打包脚本添加 `tccutil reset Accessibility` 清除旧记录

- **PATTERN-011**: PyObjC 命名冲突
  - **特征**: NSObject 子类中的 `_xxx` 方法被误认为 ObjC 属性访问器
  - **修正**: 辅助方法提取到类外部作为普通函数

- **PATTERN-012**: AppleScript 格式敏感
  - **特征**: 简化 AppleScript 后返回空结果
  - **修正**: 保持原始格式，先 `set` 赋值再 `repeat` 遍历，三引号后要有换行

- **PATTERN-016**: Event Tap 恢复
  - **特征**: 显示模态对话框后 Event Tap 停止工作
  - **修正**: 五层防护机制（不激活应用、立即恢复、延迟恢复、回调恢复、重新创建）

- **PATTERN-017**: NSAlert 输入框无法粘贴
  - **特征**: NSAlert 弹窗中的 NSTextField 无法响应 ⌘+V 粘贴操作
  - **原因**: 缺少标准的 Edit 菜单，macOS 需要通过菜单系统路由标准快捷键（⌘+C/⌘+V/⌘+X/⌘+A）
  - **修正**: 创建标准的应用程序菜单栏，包含 Edit 菜单，注册标准操作方法（cut:, copy:, paste:, selectAll:）
  - **文件**: `test/test_alert_input.py`
  - **时间**: 2026-01-14
  - **知识点**: 
    - macOS 应用架构中，菜单栏是应用的一部分，不是可选装饰
    - 标准快捷键（⌘+C/⌘+V）通过菜单系统路由到第一响应者
    - NSTextField 虽然实现了 copy:/paste: 方法，但需要菜单项才能被系统调用
    - 即使应用没有可见菜单栏，也需要注册菜单项才能响应标准快捷键
  - **代码示例**:
    ```python
    def setup_edit_menu(app):
        menubar = NSMenu.alloc().init()
        edit_menu = NSMenu.alloc().initWithTitle_("Edit")
        edit_menu.addItemWithTitle_action_keyEquivalent_("Cut", "cut:", "x")
        edit_menu.addItemWithTitle_action_keyEquivalent_("Copy", "copy:", "c")
        edit_menu.addItemWithTitle_action_keyEquivalent_("Paste", "paste:", "v")
        edit_menu.addItemWithTitle_action_keyEquivalent_("Select All", "selectAll:", "a")
        app.setMainMenu_(menubar)
    ```

### 重构陷阱

- **PATTERN-013**: 函数返回值
  - **特征**: 调用返回新对象的函数时未接收返回值
  - **修正**: 必须接收返回值 `obj = func(obj, ...)`

- **PATTERN-014**: 导入语句
  - **特征**: 重构时删除或遗漏必要的 import 语句
  - **修正**: 重构后验证所有导入语句完整

- **PATTERN-015**: 状态重置
  - **特征**: 用户选择"取消"后错误重置状态跟踪变量
  - **修正**: 取消操作保持状态不变，只有执行操作后才重置

## 关键经验

### Event Tap 五层防护机制

macOS 在显示模态对话框时会自动禁用 Event Tap，必须主动恢复。五层防护：

1. **不激活应用**：弹窗显示时不调用 `activateIgnoringOtherApps`，保持 Finder 为活动窗口
2. **立即恢复**：弹窗关闭后立即调用 `ensure_enabled()`
3. **延迟恢复**：使用多次延迟（50ms、100ms、200ms）确保系统完全退出模态状态
4. **回调恢复**：在 Event Tap 回调开始时检查并自动恢复
5. **重新创建**：如果重新启用失败，完全重新创建 Event Tap

关键点：系统退出模态状态需要时间，立即恢复可能失败，必须使用多层防护机制确保恢复成功。

### NSAlert 输入框粘贴问题

**问题现象**：NSAlert 弹窗中的 NSTextField 无法响应 ⌘+V 粘贴操作，即使输入框有焦点。

**根本原因**：macOS 应用架构中，标准快捷键（⌘+C/⌘+V/⌘+X/⌘+A）通过菜单系统路由。没有标准的 Edit 菜单，系统不会将快捷键事件路由到第一响应者的相应方法。

**解决方案**：
1. 创建标准的应用程序菜单栏（`NSMenu`）
2. 添加 Edit 菜单，注册标准操作方法：
   - `cut:` (⌘+X)
   - `copy:` (⌘+C)
   - `paste:` (⌘+V)
   - `selectAll:` (⌘+A)
3. 使用 `app.setMainMenu_(menubar)` 设置为主菜单

**关键理解**：
- 菜单栏是 macOS 应用架构的核心部分，不是可选装饰
- NSTextField 虽然实现了 `copy:`, `paste:` 等方法，但需要菜单项才能被系统调用
- 即使应用没有可见菜单栏（如状态栏应用），也需要注册菜单项才能响应标准快捷键
- 不需要手动处理焦点设置，系统会自动处理（有了菜单后）

**错误做法**：
- ❌ 使用通知观察者（`NSWindowDidBecomeKeyNotification`）延迟设置焦点
- ❌ 使用 NSTimer 延迟设置焦点
- ❌ 手动实现粘贴逻辑

**正确做法**：
- ✅ 创建标准 Edit 菜单
- ✅ 让系统自动处理快捷键路由
- ✅ 简化代码，遵循系统机制
